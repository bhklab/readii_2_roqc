from typing import Optional

import pandas as pd
from readii.utils import logger


def roi_filter_mask_metadata(mask_metadata:pd.DataFrame,
                             dataset_config:dict
                            ) -> pd.DataFrame:
    """Filter mask metadata dataframe for specific ROI regex from a dataset config file"""
    # Get the metadata rows with the specified ROIs - here for when autopipeline is run with more ROIs set to be extracted than want to be processed with R2R
    roi_regex = dataset_config["MIT"]["ROI_MATCH_MAP"]
    roi_strategy = dataset_config["MIT"]["ROI_STRATEGY"]
    mask_modality = dataset_config["MIT"]["MODALITIES"]["mask"]

    roi_regex_list = roi_regex.split(":")
    roi_key = roi_regex_list[0]
    roi_matches = roi_regex_list[1].strip("'").split(",")

    match roi_strategy:
        case 'MERGE':
            filtered_mask_metadata = mask_metadata[(mask_metadata['ImageID'] == roi_key) & (mask_metadata['Modality'] == mask_modality)] 
        case 'SEPARATE':
            # Get the combined roi key and match in the format generated by autopipeline separate = {roi_key}__{roi_items} with necessary escape characters for regex
            image_id_regex_combos = {rf"{roi_key}__\[{item}\]" for item in roi_matches}
            # Join each combination into a single regex string, separated by | for or
            image_id_regex = r"|".join(image_id_regex_combos)
            # Set a copy of the ImageID column as the index for the filtering function to use
            filtered_mask_metadata = mask_metadata.set_index('ImageID', drop=False)
            # Filter the dataset based on the regex string generated from the ROI Match Map
            filtered_mask_metadata = filtered_mask_metadata.filter(regex=image_id_regex, axis=0)
            # Restore the numeric index
            filtered_mask_metadata = filtered_mask_metadata.reset_index(drop=True)
            filtered_mask_metadata = filtered_mask_metadata[filtered_mask_metadata['Modality'] == mask_modality] 
        case _:
            message = f"The roi strategy {roi_strategy} is not handled by this function. No filtering will be applied."
            logger.info(message)
            filtered_mask_metadata = mask_metadata

    if filtered_mask_metadata.empty:
        message = f"No mask metadata found for {roi_regex} with {roi_strategy} strategy. Try changing input strategy and confirm mask modality ({mask_modality}) is correct."
        logger.error(message)
        raise RuntimeError(message)

    return filtered_mask_metadata



def get_masked_image_metadata(dataset_index:pd.DataFrame,
                              dataset_config:dict,
                              image_modality:Optional[str] = None,
                              mask_modality:Optional[str] = None
                              ) -> pd.DataFrame:
    """Get rows of Med-ImageTools index.csv with the mask modality and the corresponding image modality and create a new index with just these rows for READII
    
    Parameters
    ----------
    dataset_index : pd.DataFrame
        DataFrame loaded from a Med-ImageTools index.csv containing image metadata. Must have columns for Modality, ReferencedSeriesUID, and SeriesInstanceUID.
    dataset_config : dict
        Dictionary of configuration settings to get image and mask modality from for filtering dataset_index. Must include MIT MODALITIES image, mask, ROI_STRATEGY and ROI_MATCH_MAP. Expected output from running loadImageDatasetConfig.
    image_modality : Optional[str]
        Image modality to filter dataset_index with. Will override dataset_config setting.
    mask_modality : Optional[str]
        Mask modality to filter dataset_index with. Will override dataset_config setting.

    Returns
    -------
    pd.DataFrame
        Subset of the dataset_index with just the masks and their reference images' metadata.
    """

    if image_modality is None:
        if dataset_config is None:
            message = "No image modality setting passed. Must pass a image_modality or dataset_config with an image modality setting."
            logger.error(message)
            raise ValueError(message)
        
        # Get the image modality from config to retrieve from the metadata
        image_modality = dataset_config["MIT"]["MODALITIES"]["image"]
    
    if mask_modality is None:
        if dataset_config is None:
            message = "No mask modality setting passed. Must pass a mask_modality or dataset_config with a mask modality setting."
            logger.error(message)
            raise ValueError(message)
        
        # Get the mask modality from config to retrieve from the metadata
        mask_modality = dataset_config["MIT"]["MODALITIES"]["mask"]

    # Get all metadata rows with the mask modality
    mask_metadata = dataset_index[dataset_index['Modality'] == mask_modality]
    # Filter the mask metadata by the specified ROIs in the config file
    mask_metadata = roi_filter_mask_metadata(mask_metadata, dataset_config)
    
    # Get a Series of ReferenceSeriesUIDs from the masks - these point to the images the masks were made on
    referenced_series_ids = mask_metadata['ReferencedSeriesUID']
    
    # Get image metadata rows with a SeriesInstanceUID matching one of the ReferenceSeriesUIDS of the masks
    image_metadata = dataset_index[dataset_index['Modality'] == image_modality]
    if image_metadata.empty:
        message = f"No image metadata found with Modality == {image_modality}."
        logger.error(message)
        raise RuntimeError(message)

    masked_image_metadata = image_metadata[image_metadata['SeriesInstanceUID'].isin(referenced_series_ids)]
    if masked_image_metadata.empty:
        message = f"No {image_modality} images in dataset index are referenced by the {mask_modality} masks. Check dataset index for errors or missing data."
        logger.error(message)
        raise RuntimeError(message)
    
    # Return the subsetted metadata
    return pd.concat([masked_image_metadata, mask_metadata], sort=True)